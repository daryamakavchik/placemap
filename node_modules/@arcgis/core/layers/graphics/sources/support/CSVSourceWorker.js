/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import e from"../../../../request.js";import{createTask as t}from"../../../../core/asyncUtils.js";import i from"../../../../core/Error.js";import r from"../../../../core/Logger.js";import{isAbortError as n}from"../../../../core/promiseUtils.js";import{urlToObject as s,getFilename as o}from"../../../../core/urlUtils.js";import{projectMany as a}from"../../../../geometry/projection.js";import{jsonAdapter as l}from"../../../../geometry/geometryAdapters/json.js";import{equals as m,isWebMercator as c,WGS84 as u}from"../../../../geometry/support/spatialReferenceUtils.js";import{lngLatToXY as d}from"../../../../geometry/support/webMercatorUtils.js";import{OptimizedFeature as f}from"../../OptimizedFeature.js";import p from"../../OptimizedGeometry.js";import y from"../../data/FeatureStore.js";import{checkProjectionSupport as h}from"../../data/projectionSupport.js";import{QueryEngine as g}from"../../data/QueryEngine.js";import{parseRows as _,isValidDate as I,parseNumber as F,readRows as w,inferDelimiterAndLocationInfo as E,splitSingleRow as T,inferFields as j}from"../csv/csv.js";import{createDefaultAttributesFunction as x,createDrawingInfo as S}from"./clientSideDefaults.js";import N from"../../../support/FieldsIndex.js";import{getFieldDefaultValue as q}from"../../../support/fieldUtils.js";import C from"../../../../geometry/SpatialReference.js";const b=S("esriGeometryPoint"),v=["csv"],D=[0,0];class O{constructor(e,t){this.x=e,this.y=t}}class k{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){this._queryEngine?.destroy(),this._queryEngine=null}async load(e,t={}){this._loadOptions=e;const[i]=await Promise.all([this._fetch(t.signal),this._checkProjection(e?.parsingOptions?.spatialReference)]),r=P(i,e);this._locationInfo=r.locationInfo,this._delimiter=r.delimiter,this._queryEngine=this._createQueryEngine(r);const n=await this._createFeatures(i);if(this._queryEngine.featureStore.addMany(n),r.layerDefinition.extent=this._queryEngine.fullExtent,r.layerDefinition.timeInfo){const{start:e,end:t}=this._queryEngine.timeExtent;r.layerDefinition.timeInfo.timeExtent=[e,t]}return r}async applyEdits(){throw new i("csv-layer:editing-not-supported","applyEdits() is not supported on CSVLayer")}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(e,t.signal)}async refresh(e){return this._loadOptions.customParameters=e,this._snapshotTask?.abort(),this._snapshotTask=t(this._snapshotFeatures),this._snapshotTask.promise.then((e=>{this._queryEngine.featureStore.clear(),e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),n(e)||r.getLogger("esri.layers.CSVLayer").error(new i("csv-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent}}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:r,customParameters:n}=this._loadOptions;if(!r)throw new i("csv-layer:invalid-source","url not defined");const o=s(r);return(await e(o.path,{query:{...o.query,...n},responseType:"text",signal:t})).data}_createQueryEngine(e){const{objectIdField:t,fields:i,extent:r,timeInfo:n}=e.layerDefinition,s=new y({geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1});return new g({fields:i,geometryType:"esriGeometryPoint",hasM:!1,hasZ:!1,timeInfo:n,objectIdField:t,spatialReference:r.spatialReference||{wkid:4326},cacheSpatialQueries:!0,featureStore:s})}async _createFeatures(e){const{latitudeFieldName:t,longitudeFieldName:i}=this._locationInfo,{objectIdField:r,fieldsIndex:n,spatialReference:s}=this._queryEngine;let o=[];const u=[],y=n.fields.filter((e=>e.name!==r)).map((e=>e.name));let h=0;const g={};for(const a of n.fields)if("esriFieldTypeOID"!==a.type&&"esriFieldTypeGlobalID"!==a.type){const e=q(a);void 0!==e&&(g[a.name]=e)}const w=_(e,y,this._delimiter,x(g,r));for(const a of w){const e=this._parseCoordinateValue(a[t]),s=this._parseCoordinateValue(a[i]);if(null!=s&&null!=e&&!isNaN(e)&&!isNaN(s)){a[t]=e,a[i]=s;for(const e in a)if(e!==t&&e!==i)if(n.isDateField(e)){const t=new Date(a[e]);a[e]=I(t,a[e])?t.getTime():null}else if(n.isNumericField(e)){const t=F(a[e]);isNaN(t)?a[e]=null:a[e]=t}a[r]=h,h++,o.push(new O(s,e)),u.push(a)}}if(!m({wkid:4326},s))if(c(s))for(const a of o)[a.x,a.y]=d(a.x,a.y,D);else o=a(l,o,C.WGS84,s,null,null);const E=[];for(let a=0;a<o.length;a++){const{x:e,y:t}=o[a],i=u[a];i[r]=a+1,E.push(new f(new p([],[e,t]),i,null,i[r]))}return E}_parseCoordinateValue(e){if(null==e||""===e)return null;let t=F(e);return(isNaN(t)||Math.abs(t)>181)&&(t=parseFloat(e)),t}async _checkProjection(e){try{await h(u,e)}catch{throw new i("csv-layer:projection-not-supported","Projection not supported")}}}function P(e,t){const r=t.parsingOptions||{},n={delimiter:r.delimiter,layerDefinition:null,locationInfo:{latitudeFieldName:r.latitudeField,longitudeFieldName:r.longitudeField}},s=n.layerDefinition={name:o(t.url,v)||"csv",drawingInfo:b,geometryType:"esriGeometryPoint",objectIdField:null,fields:[],timeInfo:r.timeInfo,extent:{xmin:Number.POSITIVE_INFINITY,ymin:Number.POSITIVE_INFINITY,xmax:Number.NEGATIVE_INFINITY,ymax:Number.NEGATIVE_INFINITY,spatialReference:r.spatialReference||{wkid:102100}}},a=w(e),l=a.next().value?.trim(),m=a.next().value?.trim();if(!l)throw new i("csv-layer:empty-csv","CSV is empty",{csv:e});const{delimiter:c,locationInfo:u}=E(l,m,r);if(!c)throw new i("csv-layer:invalid-delimiter","Unable to detect the delimiter from CSV");if(!u)throw new i("csv-layer:location-fields-not-found","Unable to identify latitude and longitude fields from the CSV file");n.locationInfo=u,n.delimiter=c;const d=T(l,c).filter(Boolean),f=j(e,n.delimiter,d,n.locationInfo);if(r.fields&&r.fields.length){const e=new Map;for(const t of r.fields)e.set(t.name.toLowerCase(),t);for(const t of f){const i=e.get(t.name.toLowerCase());if(i){const e=t.name;Object.assign(t,i),t.name=e}}}s.fields=f;if(!s.fields.some((e=>"esriFieldTypeOID"===e.type&&(s.objectIdField=e.name,!0)))){const e={name:"__OBJECTID",alias:"__OBJECTID",type:"esriFieldTypeOID",editable:!1,nullable:!1};s.objectIdField=e.name,s.fields.unshift(e)}if(s.timeInfo){const e=new N(s.fields),t=s.timeInfo;if(t.startTimeField){const i=e.get(t.startTimeField);i?(t.startTimeField=i.name,i.type="esriFieldTypeDate"):t.startTimeField=null}if(t.endTimeField){const i=e.get(t.endTimeField);i?(t.endTimeField=i.name,i.type="esriFieldTypeDate"):t.endTimeField=null}if(t.trackIdField){const i=e.get(t.trackIdField);t.trackIdField=i?i.name:null}t.startTimeField||t.endTimeField||(s.timeInfo=null)}return n}export{k as default};
