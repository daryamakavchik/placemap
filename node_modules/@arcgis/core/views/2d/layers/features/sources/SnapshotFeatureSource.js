/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import t from"../../../../../core/Logger.js";import{unwrapOrThrow as e,isSome as s,isNone as r}from"../../../../../core/maybe.js";import{throwIfAborted as o,after as i}from"../../../../../core/promiseUtils.js";import a from"../../../../../core/RandomLCG.js";import{BaseFeatureSource as n}from"./BaseFeatureSource.js";import{FeatureSetReaderIndirect as d}from"../support/FeatureSetReaderPBFIndirect.js";import{UpdateToken as u}from"../support/UpdateToken.js";function h(t,e,s){const r=t.getXHydrated(),o=t.getYHydrated(),i=e.getColumnForX(r),a=Math.floor(e.normalizeCol(i));return`${s}/${Math.floor(e.getRowForY(o))}/${a}`}function l(t,e){if(r(t))return null;const s=e.transform,o=t.getQuantizationTransform();if(r(o)){const[e,r]=s.scale,[o,i]=s.translate,a=-o/e,n=1/e,d=i/r,u=1/-r;return t.transform(a,d,n,u)}const[i,a]=o.scale,[n,d]=o.translate,[u,h]=s.scale,[l,c]=s.translate,_=i/u,g=(n-l)/u,p=a/h,f=(-d+c)/h;return t.transform(g,f,_,p)}class c extends n{constructor(t){super(t),this.mode="snapshot",this._loading=!0,this._controller=new AbortController,this._downloadPromise=null,this._didSendEnd=!1,this._queries=new Array,this._invalidated=!1,this._hasAggregates=!1,this._random=new a(1e3),this._store=t.store,this._markedIdsBufId=this._store.storage.createBitset()}destroy(){super.destroy(),this._controller.abort()}get loading(){return this._loading}get _signal(){return this._controller.signal}update(t,e){super.update(t,e),null==this._featureCount&&(this._featureCount=e.initialFeatureCount),this._hasAggregates=t.targets.aggregate}async resend(t=!1){if(await this._downloadPromise,this._invalidated||t){const t=e(this._featureCount,"Expected featureCount to be defined");return this._invalidated=!1,this._subscriptions.forEach((t=>t.clear())),this._downloadPromise=this._download(t),void await this._downloadPromise}const s=this._queries.map((({query:t,reader:e})=>this._sendPatchQuery(t,e)));await Promise.all(s),this._subscriptions.forEach((t=>{t.requests.done.forEach((t=>this._onMessage(t.message)))}))}async refresh(t,e){e&&(this._featureCount=e.featureCount),await this.resend(!0)}async _sendPatchQuery(t,e){const r=s(t.outFields)?t.outFields:[],i=this._queryInfo.outFields,a=i.filter((t=>!r.includes(t)));if(!a.length)return;const n=t.clone(),d=this._signal;n.returnGeometry=!1,n.returnCentroid=!1,n.outFields=a,t.outFields=i;const u=await this._queue.push({query:n,depth:0,signal:d});o({signal:d}),e.joinAttributes(u)}async _fetchDataTile(t){if(!this._downloadPromise){const t=e(this._featureCount,"Expected featureCount to be defined");this._downloadPromise=this._download(t)}const s=this._store.search(t),r=this._subscriptions.get(t.key.id),o=s.length-1;for(let e=0;e<o;e++){const o=l(s[e],t),a={type:"append",id:t.id,addOrUpdate:o,end:!1,status:u.empty()};r.add({query:null,message:a}),this._hasAggregates||await i(1),this._onMessage(a)}const a=l(o>=0?s[o]:null,t),n=this._didSendEnd,d={type:"append",id:t.id,addOrUpdate:a,end:n,status:u.empty()};r.add({query:null,message:d}),this._onMessage(d)}async _download(e){try{await this.whenInitialized();const t=this._store.storage.getBitset(this._markedIdsBufId),s=new Set;t.clear();const r=Math.ceil(e/this.pageSize),o=Array.from({length:r},((t,e)=>e)).sort(((t,e)=>this._random.getInt()-this._random.getInt())).map((e=>this._downloadPage(e,t,s)));await Promise.all(o),this._store.sweepFeatures(t,this._store.storage),this._store.sweepFeatureSets(s)}catch(s){t.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource").error("mapview-snapshot-source","Encountered and error when downloading feature snapshot",s)}this._sendEnd(),this._loading=!1}async _downloadPage(t,e,r){const i=this.pageSize,a={start:t*i,num:i,cacheHint:!0};s(this.maxRecordCountFactor)&&(a.maxRecordCountFactor=this.maxRecordCountFactor);const n=this.createQuery(a),d=this._signal,u=await this._queue.push({query:n,depth:t,signal:d});o({signal:d}),this._queries.push({query:n,reader:u}),this._store.insert(u),r.add(u.instance);const h=u.getCursor();for(;h.next();)e.set(h.getDisplayId());this._send(u)}_send(t){if(!this._subscriptions.size)return;let e=null;const o=new Map,i=new Set,a=new Map;this._subscriptions.forEach((t=>{const s=t.tile;o.set(s.key.id,null),e=s.tileInfoView,i.add(s.level);const{row:r,col:n}=s.key,d=`${s.level}/${r}/${n}`,u=a.get(d)??[];u.push(t),a.set(d,u)}));for(const s of i){const i=e.getLODInfoAt(s),n=t.getCursor();for(;n.next();){const t=h(n,i,s),e=n.getIndex();if(a.has(t))for(const s of a.get(t)){const t=s.tile.id;let i=o.get(t);r(i)&&(i=[],o.set(t,i)),i.push(e)}}}o.forEach(((e,r)=>{if(s(e)){const s=this._subscriptions.get(r),o={type:"append",id:r,addOrUpdate:l(d.from(t,e),s.tile),end:!1,status:u.empty()};s.add({query:null,message:o}),this._onMessage(o)}}))}_sendEnd(){this._subscriptions.forEach((t=>{const e={type:"append",id:t.tile.id,addOrUpdate:null,end:!0,status:u.empty()};t.add({query:null,message:e}),this._onMessage(e)})),this._didSendEnd=!0}}export{c as SnapshotFeatureSource};
